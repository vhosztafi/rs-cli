# RoadStatus CLI

[![CI](https://github.com/vhosztafi/rs-cli/actions/workflows/ci.yml/badge.svg)](https://github.com/vhosztafi/rs-cli/actions/workflows/ci.yml)
[![codecov](https://codecov.io/gh/vhosztafi/rs-cli/graph/badge.svg?token=K3PBFvFe60)](https://codecov.io/gh/vhosztafi/rs-cli)

A .NET console application that queries the TfL Road API to display road status information.

## Overview

This application queries the Transport for London (TfL) Road API to retrieve and display the status of major roads. Given a valid road ID, it displays the road's display name, status severity, and status description. For invalid road IDs, it returns an informative error message and exits with a non-zero error code.

## Build

```bash
dotnet build
```

## Run

The application works without API credentials, but setting them enables higher rate limits (500 requests/minute). To use credentials, set them as environment variables:

```bash
export TFL_APP_ID=your_app_id
export TFL_APP_KEY=your_app_key
```

Then run:

```bash
dotnet run --project src/RoadStatus.Cli -- <road-id>
```

## Examples

### Success case (A2)

```bash
dotnet run --project src/RoadStatus.Cli -- A2
```

Output:
```
The status of the A2 is as follows
        Road Status is Good
        Road Status Description is No Exceptional Delays
```

Exit code: `0`

### Error case (A233)

```bash
dotnet run --project src/RoadStatus.Cli -- A233
```

Output:
```
A233 is not a valid road
```

Exit code: `1`

### Check exit code (PowerShell)

```powershell
dotnet run --project src/RoadStatus.Cli -- A2
$lastexitcode
```

## Tests

### Running Tests

Run all tests:

```bash
dotnet test
```

Or use the provided test scripts that include code coverage collection:

- **Windows (PowerShell)**:
  ```powershell
  .\scripts\test.ps1
  ```

- **Linux/macOS (Bash)**:
  ```bash
  ./scripts/test.sh
  ```

### Code Coverage

Code coverage is automatically collected when using the test scripts. The coverage data is generated in **Cobertura XML format**, which is compatible with Azure DevOps pipelines and many other CI/CD platforms.

#### Running Tests with Coverage

The test scripts (`test.ps1` and `test.sh`) automatically collect code coverage:

- **Windows (PowerShell)**:
  ```powershell
  .\scripts\test.ps1
  ```

- **Linux/macOS (Bash)**:
  ```bash
  ./scripts/test.sh
  ```

Coverage files are saved to the `TestResults` directory in Cobertura XML format (`coverage.cobertura.xml`).

#### Generating HTML Coverage Reports

To generate human-readable HTML coverage reports, use the coverage report generation scripts:

- **Windows (PowerShell)**:
  ```powershell
  .\scripts\generate-coverage-report.ps1
  ```

- **Linux/macOS (Bash)**:
  ```bash
  ./scripts/generate-coverage-report.sh
  ```

These scripts will:
1. Automatically install the `reportgenerator` .NET tool if not already present
2. Find all `coverage.cobertura.xml` files in the `TestResults` directory
3. Generate HTML reports in `TestResults/coverage/html`
4. Display the path to the generated report

Open `TestResults/coverage/html/index.html` in your web browser to view the detailed coverage report with line-by-line coverage information.

#### Coverage File Locations

- **Cobertura XML files**: `TestResults/**/coverage.cobertura.xml`
- **HTML reports**: `TestResults/coverage/html/index.html`

#### Viewing Coverage Reports

You can view coverage reports using:

- **HTML Reports**: Generated by the `generate-coverage-report` scripts (recommended for local viewing)
- **Visual Studio**: Open the Cobertura XML files directly in Visual Studio's Code Coverage viewer
- **Azure DevOps**: Coverage is automatically published when running the Azure DevOps pipeline (see [Continuous Integration](#continuous-integration) section)
- **Other tools**: Any tool that supports Cobertura XML format (e.g., SonarQube, Codecov, Coveralls)

#### CI/CD Integration

The Azure DevOps pipeline (`azure-pipelines.yml`) automatically:
- Collects code coverage during test execution
- Publishes coverage results to Azure DevOps using `PublishCodeCoverageResults@2`
- Makes coverage reports available in the Azure DevOps UI
- Publishes coverage artifacts for download

The coverage format (Cobertura XML) matches what is generated locally, ensuring consistency between local and CI/CD environments.

### Integration Tests

Integration tests are opt-in. Set `RUN_LIVE_INTEGRATION=1` along with `TFL_APP_ID` and `TFL_APP_KEY` to run live API tests.

## Git Hooks

The project includes git hooks to enforce code quality and commit message standards, similar to husky in Node.js projects.

### Installing Git Hooks

To install the git hooks, run one of the installation scripts:

- **Windows (PowerShell)**:
  ```powershell
  .\scripts\install-hooks.ps1
  ```

- **Linux/macOS (Bash)**:
  ```bash
  ./scripts/install-hooks.sh
  ```

The installation script configures git to use the `.githooks` directory for hooks.

### Commit-Message Hook

The commit-msg hook validates that commit messages follow the [Conventional Commits](https://www.conventionalcommits.org/) specification.

**Format**: `type(scope): subject`

**Allowed types**: `feat`, `fix`, `docs`, `style`, `refactor`, `test`, `chore`, `perf`, `ci`, `build`, `revert`

**Examples**:
- `feat: add new feature`
- `fix(core): resolve bug in parsing`
- `docs: update README`
- `chore: update dependencies`

Merge commits and revert commits are automatically allowed.

### Pre-Push Hook

The pre-push hook runs unit tests before allowing a push to proceed. This ensures that:
- The project builds successfully
- All unit tests pass (integration tests are excluded)

If tests fail, the push is aborted with a clear error message.

### Uninstalling Git Hooks

To uninstall the git hooks:

```bash
git config --unset core.hooksPath
```

## Continuous Integration

The project includes CI pipelines for both GitHub Actions and Azure DevOps:

### GitHub Actions

The project includes two GitHub Actions workflows:

#### CI Workflow

The CI workflow (`.github/workflows/ci.yml`) runs on push and pull requests and:
- Builds the solution
- Runs unit tests (integration tests excluded) with code coverage collection
- Uploads coverage reports to Codecov (if configured)
- Uploads coverage and test result artifacts

The pipeline runs on Ubuntu latest with .NET 8.0.

#### Nightly Integration Tests

The nightly integration tests workflow (`.github/workflows/nightly-integration-tests.yml`) runs daily at 2 AM UTC and:
- Runs integration tests against the real TfL API
- Requires `TFL_APP_ID` and `TFL_APP_KEY` GitHub secrets to be configured
- Uploads test results and coverage reports
- Can also be triggered manually via workflow_dispatch

This workflow ensures that integration with the TfL API continues to work correctly over time.

### Azure DevOps

The Azure DevOps pipeline (`azure-pipelines.yml`) provides equivalent functionality:
- Builds the solution
- Runs all tests with code coverage collection (Cobertura XML format)
- Publishes code coverage results to Azure DevOps UI using `PublishCodeCoverageResults@2`
- Publishes test results
- Uploads coverage artifacts for download

The pipeline runs on Ubuntu latest with .NET 8.0. Coverage reports are automatically available in the Azure DevOps build summary and can be viewed directly in the pipeline results.

Both pipelines can be used depending on your CI/CD platform preference.

## Configuration

The application supports multiple configuration methods with the following precedence (highest to lowest):

1. **Constructor parameters** (for testing) - highest priority
2. **Environment variables** - override appsettings.json
3. **appsettings.json** - default configuration file
4. **Default values** - hardcoded defaults

### API Keys

The TfL Road API can be used without authentication, but authenticated requests benefit from higher rate limits (500 requests/minute vs. lower limits for unauthenticated requests).

To use API credentials, you can configure them via **appsettings.json** or **environment variables**:

#### Option 1: appsettings.json (Recommended for Development)

Create or edit `appsettings.json` in the application directory:

```json
{
  "TflApi": {
    "BaseUrl": "https://api.tfl.gov.uk",
    "AppId": "your_app_id_here",
    "AppKey": "your_app_key_here"
  }
}
```

**Note**: For security, consider leaving `AppId` and `AppKey` empty in `appsettings.json` and using environment variables instead (see Option 2).

#### Option 2: Environment Variables (Recommended for Production)

Environment variables override values from `appsettings.json`:

- **Windows (PowerShell)**:
  ```powershell
  $env:TFL_APP_ID="your_app_id_here"
  $env:TFL_APP_KEY="your_app_key_here"
  ```
- **Windows (CMD)**:
  ```cmd
  set TFL_APP_ID=your_app_id_here
  set TFL_APP_KEY=your_app_key_here
  ```
- **Linux/macOS (Bash)**:
  ```bash
  export TFL_APP_ID=your_app_id_here
  export TFL_APP_KEY=your_app_key_here
  ```

### Base URL

The application defaults to `https://api.tfl.gov.uk` but can be configured via:

1. **appsettings.json**:
   ```json
   {
     "TflApi": {
       "BaseUrl": "https://custom.api.tfl.gov.uk"
     }
   }
   ```

2. **Environment variable** (overrides appsettings.json):
   ```bash
   export TFL_BASE_URL="https://custom.api.tfl.gov.uk"
   ```

3. **Constructor parameter** (for testing):
   ```csharp
   var client = new TflRoadStatusClient(httpClient, baseUrl: "https://test.api.tfl.gov.uk");
   ```

### Configuration Precedence Example

If you have:
- `appsettings.json` with `AppId: "appsettings-id"`
- Environment variable `TFL_APP_ID="env-id"`

The application will use `"env-id"` because environment variables override appsettings.json.

### Security Note

Never commit API keys to version control. Use environment variables, secure configuration files, or secret management systems in production environments. Consider adding `appsettings.json` to `.gitignore` if it contains sensitive information.

## Assumptions

- **API Credentials**: TfL API credentials (`TFL_APP_ID` and `TFL_APP_KEY`) are optional. The API works without them but with lower rate limits.

- **Network Connectivity**: Network connectivity is available to reach `https://api.tfl.gov.uk`. The application requires internet access to query the TfL Road API.

- **Road ID Format**: Road IDs are case-insensitive (the API handles this). Valid road IDs follow TfL's naming conventions (e.g., "A2", "A233").

- **JSON Response Format**: The application expects JSON responses with properties `displayName`, `statusSeverity`, and `statusSeverityDescription` (case-insensitive matching is supported).

- **Runtime**: The application targets .NET 8.0 and requires the .NET 8.0 runtime or SDK to build and run.

- **Single Road Query**: The application queries one road at a time. Multiple road IDs are not supported in a single invocation.
